1. Page Router (기존 라우팅 방식) 페이지 이동 시 브라우저는 JS 번들과
함께, getServerSideProps 또는 getStaticProps로 생성된 JSON 데이터를 따로
요청한다. 즉, 데이터(JSON)와 렌더링 로직(JS)이 분리되어 전달되는
구조이다. 이 방식은 SSR(서버사이드 렌더링)이나 SSG(정적 사이트 생성)
기반으로 동작하며, 페이지가 전환될 때마다 필요한 리소스들을 개별적으로
불러온다.

2. App Router (Next.js 13 이후의 새로운 구조) 페이지 전환 자체는 Page
Router와 마찬가지로 클라이언트 사이드 렌더링(CSR) 방식으로 처리된다.
하지만 데이터를 주고받는 구조가 다르다. App Router에서는 페이지 이동이나
프리패칭 시 서버가 JS Bundle과 함께 RSC Payload(React Server Component
데이터)를 같이 전달한다. 이는 서버 컴포넌트가 클라이언트에 완전한 UI를
렌더링하기 위해 필요한 데이터(서버 측 렌더링 결과)를 포함하기 때문이다. 즉, 서버 컴포넌트(Server Component) RSC Payload 클라이언트
컴포넌트(Client Component) JS Bundle 로 나누어 브라우저로 전송된다.

3. 페이지 유형별 렌더링 전략: 정적 페이지 빌드 시점에 미리 생성되는
페이지는 추가적인 데이터 요청 없이 완성된 페이지를 바로 전달 브라우저로는
JS Bundle 전체가 함께 전송됨 자주 변하지 않는 콘텐츠(예: 소개 페이지,
공지 등)에 적합하다. 동적 페이지 사용자의 요청마다 서버에서 즉시 생성되는
페이지 이미 서버에서 렌더링된 UI만 전달하므로, 브라우저는 JS 번들 대신
RSC Payload만 요청한다. 데이터가 자주 바뀌는 페이지(예: 실시간 검색
결과, 상세 조회 등)에 유용

4. 서버 컴포넌트 서버에서만 실행되므로 async 키워드를
붙여 비동기 함수로 작성 가능하다. 컴포넌트 내부에서 await와 fetch()를
사용해 데이터를 직접 가져올 수 있다. 별도의 getServerSideProps나
getStaticProps 없이 컴포넌트 단위로 데이터 패칭이 가능하다.

5. 클라이언트 컴포넌트 브라우저에서 실행되기 때문에
async 함수로 만들 수 없다. 과거의 getServerSideProps, getStaticProps,
getStaticPath 등을 사용할 수 없으며, 대신 props로 전달받거나 상위 서버
컴포넌트에서 패칭된 데이터를 사용한다. 데이터 패칭 방식이 "페이지
단위"에서 "컴포넌트 단위"로 변화되었다.

6. 데이터 캐시 fetch()로 불러온 데이터를 Next.js 서버가
자동으로 저장하고 재활용한다. 데이터를 일정 주기로 갱신하거나 영구적으로
보관할 수 있어, 불필요한 요청을 줄이고 성능을 개선한다.

7. Request Memoization 같은 렌더링 과정에서 동일한
URL로 fetch()를 여러 번 호출하더라도 실제 네트워크 요청은 단 한 번만
발생하도록 자동 최적화된다. 데이터 캐시와는 별개로, 렌더링이 끝나면
메모리에서 사라진다. cache: "no-store" 옵션을 사용할 때 기본적으로
활성화된다.
